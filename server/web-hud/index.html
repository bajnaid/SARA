<!doctype html>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>SARA HUD</title>

<style>
  :root { font: 16px/1.4 system-ui, -apple-system, Segoe UI, Roboto, sans-serif; }
  body { margin: 24px; max-width: 980px; transition: background .2s, color .2s; }
  h1 { margin: 0 0 8px; }
  .topbar { display:flex; gap:12px; align-items:center; justify-content:space-between; margin-bottom: 16px; }
  .muted { color: #666; }
  .row { display: flex; gap: 24px; flex-wrap: wrap; }
  .col { flex: 1 1 460px; min-width: 320px; }
  pre, textarea, input { width: 100%; box-sizing: border-box; }
  pre { background:#0b1020; color:#cde3ff; padding:12px; border-radius:8px; overflow:auto; min-height:140px; }
  textarea { min-height:140px; padding:12px; border-radius:8px; border:1px solid #ddd; font: inherit; }
  .controls { display:flex; gap:12px; align-items:center; margin-top:10px; flex-wrap: wrap; }
  button { padding:10px 14px; border-radius:8px; border:0; cursor:pointer; font: inherit; }
  button.primary { background:#2b7fff; color:#fff; }
  button.secondary { background:#eee; }
  button[disabled] { opacity:.6; cursor:not-allowed; }
  .ok { color:#0b8f39; }
  .err { color:#b00020; }
  small.mono { font-family: ui-monospace, SFMono-Regular, Menlo, monospace; }
  .flash { animation: flash 1.2s ease-out 1; }
  @keyframes flash { 0%{opacity:0} 20%{opacity:1} 80%{opacity:1} 100%{opacity:0} }

  /* Dark theme */
  .dark body { background:#0b0e14; color:#e6e6e6; }
  .dark .muted { color:#9aa1ad; }
  .dark textarea { background:#0f131a; color:#e6e6e6; border-color:#2a3342; }
  .dark .secondary { background:#1b2230; color:#e6e6e6; }
</style>

<div class="topbar">
  <div>
    <h1>SARA HUD</h1>
    <p class="muted">Talking to <span id="base"></span></p>
  </div>
  <div class="controls">
    <button id="theme" class="secondary" title="Toggle light/dark">Toggle Theme</button>
    <a class="secondary" href="/docs" style="padding:10px 14px; border-radius:8px; text-decoration:none; display:inline-block;">Open API docs</a>
  </div>
</div>

<div class="row">
  <div class="col">
    <h2>Current Card</h2>
    <pre id="card">Loading‚Ä¶</pre>
    <div class="controls">
      <button id="refresh" class="secondary" title="Cmd/Ctrl + Shift + R">Refresh</button>
      <small class="muted">Shortcut: <span class="mono">Cmd/Ctrl + Shift + R</span></small>
    </div>
  </div>

  <div class="col">
    <h2>New Reflection</h2>
    <label for="reflectText" class="muted">What‚Äôs on your mind?</label>
    <textarea id="reflectText" placeholder="Type a quick note‚Ä¶  (Cmd/Ctrl + Enter to save)" autofocus></textarea>

    <div class="controls">
      <button class="primary" id="save">Save Reflection</button>
      <span id="status" class="muted"></span>
    </div>
    <!-- buttons row -->
    <div style="display:flex; gap:8px; align-items:center; margin-top:8px;">
      <button id="pttBtn" class="secondary" title="Hold to talk">üéôÔ∏è Hold to talk</button>
      <button id="askBtn" class="secondary" title="Send the text above to SARA and hear the reply">ü§ñ Ask SARA</button>
      <label style="display:inline-flex;gap:6px;align-items:center;">
        <input type="checkbox" id="handsFree" />
        Hands-free
      </label>
      <audio id="ttsAudio" controls style="display:none;"></audio>
    </div>

    <details style="margin-top:10px;">
      <summary>Advanced: API key (optional)</summary>
      <label for="apiKey">API_KEY for /api/reflect (Bearer):</label>
      <input id="apiKey" type="password" placeholder="Leave blank if your endpoint is open" />
      <div class="controls">
        <button id="saveKey" class="secondary">Save key (local)</button>
        <button id="clearKey" class="secondary">Clear key</button>
        <span id="keyStatus" class="muted"></span>
      </div>
      <small class="mono muted">Key is stored only in this browser (localStorage).</small>
    </details>

    <h3 style="margin-top:16px;">Last result</h3>
    <pre id="result">‚Äî</pre>
  </div>
</div>

<script>
  // ---------- Config ----------
  const API_BASE = window.location.origin;
  document.getElementById('base').textContent = API_BASE;

  // Theme
  const root = document.documentElement;
  const savedTheme = localStorage.getItem('SARA_THEME');
  if (savedTheme === 'dark' || (!savedTheme && window.matchMedia('(prefers-color-scheme: dark)').matches)) {
    document.documentElement.classList.add('dark');
  }
  document.getElementById('theme').onclick = () => {
    document.documentElement.classList.toggle('dark');
    localStorage.setItem('SARA_THEME', document.documentElement.classList.contains('dark') ? 'dark' : 'light');
  };

  // Key management (optional)
  const keyInput = document.getElementById('apiKey');
  const keyStatus = document.getElementById('keyStatus');
  keyInput.value = localStorage.getItem('SARA_API_KEY') || '';
  const bearerHeaders = () => {
    const headers = { 'Content-Type': 'application/json' };
    const k = (localStorage.getItem('SARA_API_KEY') || '').trim();
    if (k) headers['Authorization'] = 'Bearer ' + k;
    return headers;
  };
  document.getElementById('saveKey').onclick = () => {
    localStorage.setItem('SARA_API_KEY', keyInput.value || '');
    keyStatus.textContent = 'Key saved';
    setTimeout(()=> keyStatus.textContent = '', 1200);
  };
  document.getElementById('clearKey').onclick = () => {
    localStorage.removeItem('SARA_API_KEY');
    keyInput.value = '';
    keyStatus.textContent = 'Key cleared';
    setTimeout(()=> keyStatus.textContent = '', 1200);
  };

  // ---------- API ----------
  async function loadCard() {
    const out = document.getElementById('card');
    out.textContent = 'Loading‚Ä¶';
    try {
      const r = await fetch(`${API_BASE}/api/currentCard`, {
        headers: { 'Accept': 'application/json' }
      });
      const ct = (r.headers.get('content-type') || '').toLowerCase();
      if (!r.ok) {
        const body = await r.text();
        throw new Error(`HTTP ${r.status} on /api/currentCard ‚Äî ${body.slice(0,200)}`);
      }
      if (ct.includes('application/json')) {
        const j = await r.json();
        out.textContent = JSON.stringify(j, null, 2);
      } else {
        const t = await r.text();
        throw new Error(`Expected JSON, got ${ct || 'unknown content-type'} ‚Äî ${t.slice(0,200)}`);
      }
    } catch (e) {
      out.textContent = String(e);
    }
  }

  async function saveReflection() {
    const status = document.getElementById('status');
    const result = document.getElementById('result');
    const saveBtn = document.getElementById('save');
    const textEl = document.getElementById('reflectText');
    const text = textEl.value.trim();

    if (!text) {
      status.textContent = 'Please type something first.';
      status.className = 'err';
      return;
    }

    // disable while saving
    saveBtn.disabled = true;
    status.textContent = 'Saving‚Ä¶';
    status.className = 'muted';

    try {
      const r = await fetch(`${API_BASE}/api/reflect`, {
        method: 'POST',
        headers: bearerHeaders(),
        body: JSON.stringify({ text })
      });
      const ct = (r.headers.get('content-type') || '').toLowerCase();
      if (!r.ok) {
        const body = await r.text();
        throw new Error(`HTTP ${r.status} on /api/reflect ‚Äî ${body.slice(0,200)}`);
      }
      let j;
      if (ct.includes('application/json')) {
        j = await r.json();
      } else {
        const t = await r.text();
        throw new Error(`Expected JSON, got ${ct || 'unknown content-type'} ‚Äî ${t.slice(0,200)}`);
      }
      result.textContent = j.summary || "Saved.";

      if (j.ok) {
        status.textContent = 'Saved ‚úì';
        status.className = 'ok flash';
        textEl.value = '';
        loadCard();
      } else {
        status.textContent = j.error || 'Failed';
        status.className = 'err';
      }
    } catch (e) {
      status.textContent = String(e);
      status.className = 'err';
    } finally {
      // Re-enable & remove flash after it completes
      saveBtn.disabled = false;
      setTimeout(() => status.classList.remove('flash'), 1200);
    }
  }

  // ---------- Wiring & Shortcuts ----------
  document.getElementById('refresh').onclick = loadCard;
  document.getElementById('save').onclick = saveReflection;

  const input = document.getElementById('reflectText');
  input.addEventListener('keydown', (e) => {
    // Save: Cmd/Ctrl + Enter
    if ((e.metaKey || e.ctrlKey) && e.key === 'Enter') {
      e.preventDefault();
      saveReflection();
    }
    // Ask SARA: Shift + Enter
    if (e.shiftKey && e.key === 'Enter') {
      e.preventDefault();
      // call askSara if it exists (defined in later script)
      if (typeof askSara === 'function') askSara();
    }
    // Clear: Esc
    if (e.key === 'Escape') {
      input.value = '';
    }
  });

  // Global: Refresh card with Cmd/Ctrl + Shift + R (avoids browser Cmd+R)
  document.addEventListener('keydown', (e) => {
    if ((e.metaKey || e.ctrlKey) && e.shiftKey && (e.key.toLowerCase() === 'r')) {
      e.preventDefault();
      loadCard();
    }
  });

  // Focus the textbox on load (autofocus attribute is a hint; do it explicitly too)
  window.addEventListener('load', () => { input.focus(); input.selectionStart = input.selectionEnd = input.value.length; });

  // Initial load
  loadCard();
</script>
<script>
async function speakText(text) {
  const apiKey = (localStorage.getItem('SARA_API_KEY') || '').trim();
  const res = await fetch(`${API_BASE}/api/tts`, {
    method: "POST",
    headers: {
      "Content-Type": "application/json",
      ...(apiKey ? { "Authorization": `Bearer ${apiKey}` } : {})
    },
    body: JSON.stringify({ text, voice: "alloy" })
  });
  if (!res.ok) {
    const err = await res.text().catch(()=>res.statusText);
    throw new Error(`TTS failed: ${res.status} ${err}`);
  }
  const blob = await res.blob();
  const url = URL.createObjectURL(blob);
  const audio = document.getElementById("ttsAudio");
  audio.style.display = "block";
  audio.src = url;
  await audio.play();
}

async function chatAndGetReply(text) {
  const apiKey = (localStorage.getItem('SARA_API_KEY') || '').trim();
  const res = await fetch(`${API_BASE}/api/chat`, {
    method: "POST",
    headers: {
      "Content-Type": "application/json",
      ...(apiKey ? { "Authorization": `Bearer ${apiKey}` } : {})
    },
    body: JSON.stringify({ text })
  });
  if (!res.ok) {
    const err = await res.text().catch(()=>res.statusText);
    throw new Error(`Chat failed: ${res.status} ${err}`);
  }
  const j = await res.json();
  if (!j || !j.ok || !j.reply) {
    throw new Error("Chat failed: empty reply");
  }
  return j.reply;
}

// --- Hold-to-talk (press and hold to record; on release: STT -> Chat -> TTS)
let mediaRecorder, chunks = [], currentStream;
const pttBtn = document.getElementById("pttBtn");
const resultBox = document.getElementById("result");

// Ask SARA with the textarea content, show and speak reply
async function askSara() {
  try {
    const textEl = document.getElementById("reflectText");
    const text = (textEl.value || "").trim();
    if (!text) { alert("Type something to ask SARA."); return; }
    // Get reply from API
    const reply = await chatAndGetReply(text);
    // Show reply in the result box
    if (resultBox) resultBox.textContent = reply;
    // Speak it
    await speakText(reply);
  } catch (e) {
    console.error(e);
    alert(e.message || "Chat failed");
  }
}

const askBtn = document.getElementById("askBtn");
if (askBtn) {
  askBtn.addEventListener("click", askSara);
}

async function startRecording() {
  try {
    currentStream = await navigator.mediaDevices.getUserMedia({ audio: true });
    chunks = [];
    mediaRecorder = new MediaRecorder(currentStream, { mimeType: "audio/webm" });
    pttBtn.textContent = "‚è∫Ô∏è Recording‚Ä¶";
    pttBtn.disabled = false; // keep enabled so mouseup can fire

    mediaRecorder.ondataavailable = (e) => { if (e.data && e.data.size) chunks.push(e.data); };
    mediaRecorder.onstop = async () => {
      try {
        const blob = new Blob(chunks, { type: "audio/webm" });
        const form = new FormData();
        form.append("audio", blob, "mic.webm");

        const apiKey = (localStorage.getItem("SARA_API_KEY") || "").trim();
        const sttRes = await fetch(`${API_BASE}/api/stt`, {
          method: "POST",
          headers: { ...(apiKey ? { "Authorization": `Bearer ${apiKey}` } : {}) },
          body: form
        });
        const stt = await sttRes.json().catch(() => ({}));
        if (!stt || !stt.ok || !stt.text) throw new Error("STT failed");

        // Inject transcript into the textarea
        const textEl = document.getElementById("reflectText");
        if (textEl) textEl.value = stt.text;

        // Ask SARA and speak the reply
        const reply = await chatAndGetReply(stt.text);
        if (resultBox) resultBox.textContent = reply;
        await speakText(reply);
      } catch (e) {
        console.error(e);
        alert(e.message || "Mic/Chat failed");
      } finally {
        pttBtn.textContent = "üéôÔ∏è Hold to talk";
        currentStream?.getTracks()?.forEach(t => t.stop());
      }
    };

    mediaRecorder.start();
  } catch (e) {
    console.error(e);
    alert("Mic access failed (check browser permissions).");
    pttBtn.textContent = "üéôÔ∏è Hold to talk";
  }
}

function stopRecording() {
  try {
    if (mediaRecorder && mediaRecorder.state !== "inactive") mediaRecorder.stop();
  } catch {}
}

if (pttBtn) {
  pttBtn.addEventListener("mousedown", startRecording);
  pttBtn.addEventListener("mouseup", stopRecording);
  pttBtn.addEventListener("mouseleave", () => { if (mediaRecorder) stopRecording(); });
  pttBtn.addEventListener("touchstart", (e)=>{ e.preventDefault(); startRecording(); }, { passive:false });
  pttBtn.addEventListener("touchend", (e)=>{ e.preventDefault(); stopRecording(); }, { passive:false });
}
</script>