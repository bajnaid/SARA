<!doctype html>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>SARA HUD</title>

<style>
  :root { font: 16px/1.4 system-ui, -apple-system, Segoe UI, Roboto, sans-serif; }
  body { margin: 24px; max-width: 980px; transition: background .2s, color .2s; }
  h1 { margin: 0 0 8px; }
  .topbar { display:flex; gap:12px; align-items:center; justify-content:space-between; margin-bottom: 16px; }
  .muted { color: #666; }
  .row { display: flex; gap: 24px; flex-wrap: wrap; }
  .col { flex: 1 1 460px; min-width: 320px; }
  pre, textarea, input { width: 100%; box-sizing: border-box; }
  pre { background:#0b1020; color:#cde3ff; padding:12px; border-radius:8px; overflow:auto; min-height:140px; }
  textarea { min-height:140px; padding:12px; border-radius:8px; border:1px solid #ddd; font: inherit; }
  .controls { display:flex; gap:12px; align-items:center; margin-top:10px; flex-wrap: wrap; }
  button { padding:10px 14px; border-radius:8px; border:0; cursor:pointer; font: inherit; }
  button.primary { background:#2b7fff; color:#fff; }
  button.secondary { background:#eee; }
  button[disabled] { opacity:.6; cursor:not-allowed; }
  .ok { color:#0b8f39; }
  .err { color:#b00020; }
  small.mono { font-family: ui-monospace, SFMono-Regular, Menlo, monospace; }
  .flash { animation: flash 1.2s ease-out 1; }
  @keyframes flash { 0%{opacity:0} 20%{opacity:1} 80%{opacity:1} 100%{opacity:0} }

  /* Dark theme */
  .dark body { background:#0b0e14; color:#e6e6e6; }
  .dark .muted { color:#9aa1ad; }
  .dark textarea { background:#0f131a; color:#e6e6e6; border-color:#2a3342; }
  .dark .secondary { background:#1b2230; color:#e6e6e6; }
</style>

<div class="topbar">
  <div>
    <h1>SARA HUD</h1>
    <p class="muted">Talking to <span id="base"></span></p>
  </div>
  <div class="controls">
    <button id="theme" class="secondary" title="Toggle light/dark">Toggle Theme</button>
    <a class="secondary" href="/docs" style="padding:10px 14px; border-radius:8px; text-decoration:none; display:inline-block;">Open API docs</a>
  </div>
</div>

<div class="row">
  <div class="col">
    <h2>Current Card</h2>
    <pre id="card">Loading‚Ä¶</pre>
    <div class="controls">
      <button id="refresh" class="secondary" title="Cmd/Ctrl + Shift + R">Refresh</button>
      <small class="muted">Shortcut: <span class="mono">Cmd/Ctrl + Shift + R</span></small>
    </div>
  </div>

  <div class="col">
    <h2>New Reflection</h2>
    <label for="reflectText" class="muted">What‚Äôs on your mind?</label>
    <textarea id="reflectText" placeholder="Type a quick note‚Ä¶  (Cmd/Ctrl + Enter to save)" autofocus></textarea>

    <div class="controls">
      <button class="primary" id="save">Save Reflection</button>
      <span id="status" class="muted"></span>
    </div>
    <div style="display:flex; gap:8px; align-items:center; margin-top:8px;">
      <button id="speakBtn">üîä Speak</button>
      <button id="micBtn">üéôÔ∏è Mic</button>
      <button id="askBtn" class="secondary">ü§ñ Ask SARA</button>
      <audio id="ttsAudio" controls style="display:none;"></audio>
    </div>

    <details style="margin-top:10px;">
      <summary>Advanced: API key (optional)</summary>
      <label for="apiKey">API_KEY for /api/reflect (Bearer):</label>
      <input id="apiKey" type="password" placeholder="Leave blank if your endpoint is open" />
      <div class="controls">
        <button id="saveKey" class="secondary">Save key (local)</button>
        <button id="clearKey" class="secondary">Clear key</button>
        <span id="keyStatus" class="muted"></span>
      </div>
      <small class="mono muted">Key is stored only in this browser (localStorage).</small>
    </details>

    <h3 style="margin-top:16px;">Last result</h3>
    <pre id="result">‚Äî</pre>
  </div>
</div>

<script>
  // ---------- Config ----------
  const API_BASE = window.location.origin;
  document.getElementById('base').textContent = API_BASE;

  // Theme
  const root = document.documentElement;
  const savedTheme = localStorage.getItem('SARA_THEME');
  if (savedTheme === 'dark' || (!savedTheme && window.matchMedia('(prefers-color-scheme: dark)').matches)) {
    document.documentElement.classList.add('dark');
  }
  document.getElementById('theme').onclick = () => {
    document.documentElement.classList.toggle('dark');
    localStorage.setItem('SARA_THEME', document.documentElement.classList.contains('dark') ? 'dark' : 'light');
  };

  // Key management (optional)
  const keyInput = document.getElementById('apiKey');
  const keyStatus = document.getElementById('keyStatus');
  keyInput.value = localStorage.getItem('SARA_API_KEY') || '';
  const bearerHeaders = () => {
    const headers = { 'Content-Type': 'application/json' };
    const k = (localStorage.getItem('SARA_API_KEY') || '').trim();
    if (k) headers['Authorization'] = 'Bearer ' + k;
    return headers;
  };
  document.getElementById('saveKey').onclick = () => {
    localStorage.setItem('SARA_API_KEY', keyInput.value || '');
    keyStatus.textContent = 'Key saved';
    setTimeout(()=> keyStatus.textContent = '', 1200);
  };
  document.getElementById('clearKey').onclick = () => {
    localStorage.removeItem('SARA_API_KEY');
    keyInput.value = '';
    keyStatus.textContent = 'Key cleared';
    setTimeout(()=> keyStatus.textContent = '', 1200);
  };

  // ---------- API ----------
  async function loadCard() {
    const out = document.getElementById('card');
    out.textContent = 'Loading‚Ä¶';
    try {
      const r = await fetch(`${API_BASE}/api/currentCard`, {
        headers: { 'Accept': 'application/json' }
      });
      const ct = (r.headers.get('content-type') || '').toLowerCase();
      if (!r.ok) {
        const body = await r.text();
        throw new Error(`HTTP ${r.status} on /api/currentCard ‚Äî ${body.slice(0,200)}`);
      }
      if (ct.includes('application/json')) {
        const j = await r.json();
        out.textContent = JSON.stringify(j, null, 2);
      } else {
        const t = await r.text();
        throw new Error(`Expected JSON, got ${ct || 'unknown content-type'} ‚Äî ${t.slice(0,200)}`);
      }
    } catch (e) {
      out.textContent = String(e);
    }
  }

  async function saveReflection() {
    const status = document.getElementById('status');
    const result = document.getElementById('result');
    const saveBtn = document.getElementById('save');
    const textEl = document.getElementById('reflectText');
    const text = textEl.value.trim();

    if (!text) {
      status.textContent = 'Please type something first.';
      status.className = 'err';
      return;
    }

    // disable while saving
    saveBtn.disabled = true;
    status.textContent = 'Saving‚Ä¶';
    status.className = 'muted';

    try {
      const r = await fetch(`${API_BASE}/api/reflect`, {
        method: 'POST',
        headers: bearerHeaders(),
        body: JSON.stringify({ text })
      });
      const ct = (r.headers.get('content-type') || '').toLowerCase();
      if (!r.ok) {
        const body = await r.text();
        throw new Error(`HTTP ${r.status} on /api/reflect ‚Äî ${body.slice(0,200)}`);
      }
      let j;
      if (ct.includes('application/json')) {
        j = await r.json();
      } else {
        const t = await r.text();
        throw new Error(`Expected JSON, got ${ct || 'unknown content-type'} ‚Äî ${t.slice(0,200)}`);
      }
      result.textContent = JSON.stringify(j, null, 2);

      if (j.ok) {
        status.textContent = 'Saved ‚úì';
        status.className = 'ok flash';
        textEl.value = '';
        loadCard();
      } else {
        status.textContent = j.error || 'Failed';
        status.className = 'err';
      }
    } catch (e) {
      status.textContent = String(e);
      status.className = 'err';
    } finally {
      // Re-enable & remove flash after it completes
      saveBtn.disabled = false;
      setTimeout(() => status.classList.remove('flash'), 1200);
    }
  }

  // ---------- Wiring & Shortcuts ----------
  document.getElementById('refresh').onclick = loadCard;
  document.getElementById('save').onclick = saveReflection;

  const input = document.getElementById('reflectText');
  input.addEventListener('keydown', (e) => {
    // Save: Cmd/Ctrl + Enter
    if ((e.metaKey || e.ctrlKey) && e.key === 'Enter') {
      e.preventDefault();
      saveReflection();
    }
    // Clear: Esc
    if (e.key === 'Escape') {
      input.value = '';
    }
  });

  // Global: Refresh card with Cmd/Ctrl + Shift + R (avoids browser Cmd+R)
  document.addEventListener('keydown', (e) => {
    if ((e.metaKey || e.ctrlKey) && e.shiftKey && (e.key.toLowerCase() === 'r')) {
      e.preventDefault();
      loadCard();
    }
  });

  // Focus the textbox on load (autofocus attribute is a hint; do it explicitly too)
  window.addEventListener('load', () => { input.focus(); input.selectionStart = input.selectionEnd = input.value.length; });

  // Initial load
  loadCard();
</script>
<script>
async function speakText(text) {
  const apiKey = (localStorage.getItem('SARA_API_KEY') || '').trim();
  const res = await fetch(`${API_BASE}/api/tts`, {
    method: "POST",
    headers: {
      "Content-Type": "application/json",
      ...(apiKey ? { "Authorization": `Bearer ${apiKey}` } : {})
    },
    body: JSON.stringify({ text, voice: "alloy" })
  });
  if (!res.ok) {
    const err = await res.text().catch(()=>res.statusText);
    throw new Error(`TTS failed: ${res.status} ${err}`);
  }
  const blob = await res.blob();
  const url = URL.createObjectURL(blob);
  const audio = document.getElementById("ttsAudio");
  audio.style.display = "block";
  audio.src = url;
  await audio.play();
}

async function chatAndGetReply(text) {
  const apiKey = (localStorage.getItem('SARA_API_KEY') || '').trim();
  const res = await fetch(`${API_BASE}/api/chat`, {
    method: "POST",
    headers: {
      "Content-Type": "application/json",
      ...(apiKey ? { "Authorization": `Bearer ${apiKey}` } : {})
    },
    body: JSON.stringify({ text })
  });
  if (!res.ok) {
    const err = await res.text().catch(()=>res.statusText);
    throw new Error(`Chat failed: ${res.status} ${err}`);
  }
  const j = await res.json();
  if (!j || !j.ok || !j.reply) {
    throw new Error("Chat failed: empty reply");
  }
  return j.reply;
}

document.getElementById("speakBtn").addEventListener("click", async () => {
  const textEl = document.getElementById("reflectText");
  const text = (textEl?.value || "").trim();
  if (!text) {
    alert("Please type something first.");
    return;
  }
  try {
    await speakText(text);
  } catch (e) {
    console.error(e);
    alert(e.message || "TTS failed");
  }
});

// Ask SARA (send text to /api/chat, then TTS the assistant reply)
const askBtn = document.getElementById("askBtn");
const resultBox = document.getElementById("result");
if (askBtn) {
  askBtn.addEventListener("click", async () => {
    const textEl = document.getElementById("reflectText");
    const text = (textEl?.value || "").trim();
    if (!text) {
      alert("Type something first or use the Mic.");
      return;
    }
    try {
      const reply = await chatAndGetReply(text);
      if (resultBox) resultBox.textContent = JSON.stringify({ ok: true, reply }, null, 2);
      await speakText(reply);
    } catch (e) {
      console.error(e);
      alert(e.message || "Chat failed");
    }
  });
}
// --- Mic (record ~6s and send to /api/stt), inject transcript into the textarea
let mediaRecorder, chunks = [];
const micBtn = document.getElementById("micBtn");
if (micBtn) {
  micBtn.addEventListener("click", async () => {
    try {
      // Request mic
      const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
      chunks = [];
      mediaRecorder = new MediaRecorder(stream);
      micBtn.disabled = true;
      micBtn.textContent = "‚è∫Ô∏è Recording‚Ä¶";

      mediaRecorder.ondataavailable = (e) => { if (e.data && e.data.size) chunks.push(e.data); };
      mediaRecorder.onstop = async () => {
        try {
          const blob = new Blob(chunks, { type: "audio/webm" });
          const form = new FormData();
          form.append("audio", blob, "mic.webm");

          const apiKey = (localStorage.getItem("SARA_API_KEY") || "").trim();
          const res = await fetch(`${API_BASE}/api/stt`, {
            method: "POST",
            headers: { ...(apiKey ? { "Authorization": `Bearer ${apiKey}` } : {}) },
            body: form
          });

          const j = await res.json().catch(() => ({}));
          if (j && j.ok && j.text) {
            const textEl = document.getElementById("reflectText");
            if (textEl) textEl.value = j.text;

            // Auto-chat with the transcription and speak the reply
            try {
              const reply = await chatAndGetReply(j.text);
              if (resultBox) resultBox.textContent = JSON.stringify({ ok: true, transcript: j.text, reply }, null, 2);
              await speakText(reply);
            } catch (e) {
              console.error(e);
              // Keep it non-blocking; user can still edit the text
            }
          } else {
            alert("STT failed");
          }
        } catch (err) {
          console.error(err);
          alert("STT upload failed");
        } finally {
          micBtn.disabled = false;
          micBtn.textContent = "üéôÔ∏è Mic";
          // Stop tracks to release the mic
          stream.getTracks().forEach(t => t.stop());
        }
      };

      mediaRecorder.start();
      // Auto stop after ~6 seconds
      setTimeout(() => {
        if (mediaRecorder && mediaRecorder.state !== "inactive") {
          mediaRecorder.stop();
        }
      }, 6000);
    } catch (e) {
      console.error(e);
      alert("Mic access failed (check browser permissions).");
      micBtn.disabled = false;
      micBtn.textContent = "üéôÔ∏è Mic";
    }
  });
}
</script>