<!doctype html>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>SARA HUD</title>

<style>
  :root { font: 16px/1.4 system-ui, -apple-system, Segoe UI, Roboto, sans-serif; }
  body { margin: 24px; max-width: 980px; transition: background .2s, color .2s; }
  h1 { margin: 0 0 8px; }
  .topbar { display:flex; gap:12px; align-items:center; justify-content:space-between; margin-bottom: 16px; }
  .muted { color: #666; }
  .row { display: flex; gap: 24px; flex-wrap: wrap; }
  .col { flex: 1 1 460px; min-width: 320px; }
  pre, textarea, input { width: 100%; box-sizing: border-box; }
  pre { background:#0b1020; color:#cde3ff; padding:12px; border-radius:8px; overflow:auto; min-height:140px; }
  textarea { min-height:140px; padding:12px; border-radius:8px; border:1px solid #ddd; font: inherit; }
  .controls { display:flex; gap:12px; align-items:center; margin-top:10px; flex-wrap: wrap; }
  .mic-btn { width:56px; height:56px; border-radius:50%; background:#1b2230; color:#fff; border:1px solid #2a3342; display:inline-flex; align-items:center; justify-content:center; font-size:22px; cursor:pointer; }
  .mic-btn.recording { background:#e53935; border-color:#b71c1c; }
  button { padding:10px 14px; border-radius:8px; border:0; cursor:pointer; font: inherit; }
  button.primary { background:#2b7fff; color:#fff; }
  button.secondary { background:#eee; }
  button[disabled] { opacity:.6; cursor:not-allowed; }
  .ok { color:#0b8f39; }
  .err { color:#b00020; }
  small.mono { font-family: ui-monospace, SFMono-Regular, Menlo, monospace; }
  .flash { animation: flash 1.2s ease-out 1; }
  @keyframes flash { 0%{opacity:0} 20%{opacity:1} 80%{opacity:1} 100%{opacity:0} }

  /* Dark theme */
  .dark body { background:#0b0e14; color:#e6e6e6; }
  .dark .muted { color:#9aa1ad; }
  .dark textarea { background:#0f131a; color:#e6e6e6; border-color:#2a3342; }
  .dark .secondary { background:#1b2230; color:#e6e6e6; }
</style>

<!-- One-time init overlay to unlock audio + request mic -->
<div id="initOverlay" style="position:fixed;inset:0;display:flex;align-items:center;justify-content:center;background:rgba(0,0,0,.82);z-index:9999;">
  <div style="background:#111;border:1px solid #333;padding:20px 24px;border-radius:12px;min-width:320px;text-align:center;box-shadow:0 10px 30px rgba(0,0,0,.35);">
    <h2 style="margin:0 0 10px">SARA is ready</h2>
    <p style="opacity:.8;margin:0 0 16px">Click start to enable audio and microphone access.</p>
    <button id="startSaraBtn" style="padding:10px 14px;border-radius:10px;border:1px solid #444;background:#1e1e1e;color:#e6e6e6;cursor:pointer">
      ‚ñ∂ Start SARA
    </button>
  </div>
</div>

<div class="topbar">
  <div>
    <h1>SARA HUD</h1>
    <p class="muted">Talking to <span id="base"></span></p>
  </div>
  <div class="controls">
    <button id="theme" class="secondary" title="Toggle light/dark">Toggle Theme</button>
    <a class="secondary" href="/docs" style="padding:10px 14px; border-radius:8px; text-decoration:none; display:inline-block;">Open API docs</a>
  </div>
</div>

<div class="row">
  <div class="col">
    <h2>Current Card</h2>
    <pre id="card">Loading‚Ä¶</pre>
    <div class="controls">
      <button id="refresh" class="secondary" title="Cmd/Ctrl + Shift + R">Refresh</button>
      <small class="muted">Shortcut: <span class="mono">Cmd/Ctrl + Shift + R</span></small>
    </div>
  </div>

  <div class="col">
    <h2>New Reflection</h2>
    <label for="reflectText" class="muted">What‚Äôs on your mind?</label>
    <textarea id="reflectText" placeholder="Type a quick note‚Ä¶  (Cmd/Ctrl + Enter to save)" autofocus></textarea>

    <div class="controls">
      <button class="primary" id="save">Save Reflection</button>
      <span id="status" class="muted"></span>
    </div>
    <!-- buttons row -->
    <div style="display:flex; gap:8px; align-items:center; margin-top:8px;">
      <button id="micBtn" class="mic-btn" title="Tap to talk">üéôÔ∏è</button>
      <button id="askBtn" class="secondary" title="Send the text above to SARA and hear the reply">ü§ñ Ask SARA</button>
      <label style="display:inline-flex;gap:6px;align-items:center;">
        <input type="checkbox" id="handsFree" />
        Hands-free
      </label>
      <audio id="ttsAudio" controls style="display:none;"></audio>
    </div>

    <details style="margin-top:10px;">
      <summary>Advanced: API key (optional)</summary>
      <label for="apiKey">API_KEY for /api/reflect (Bearer):</label>
      <input id="apiKey" type="password" placeholder="Leave blank if your endpoint is open" />
      <div class="controls">
        <button id="saveKey" class="secondary">Save key (local)</button>
        <button id="clearKey" class="secondary">Clear key</button>
        <span id="keyStatus" class="muted"></span>
      </div>
      <small class="mono muted">Key is stored only in this browser (localStorage).</small>
    </details>

    <h3 style="margin-top:16px;">Last result</h3>
    <pre id="result">‚Äî</pre>
  </div>
</div>

<script>
  // ---------- Config ----------
  const API_BASE = window.location.origin;
  document.getElementById('base').textContent = API_BASE;

  // Theme
  const root = document.documentElement;
  const savedTheme = localStorage.getItem('SARA_THEME');
  if (savedTheme === 'dark' || (!savedTheme && window.matchMedia('(prefers-color-scheme: dark)').matches)) {
    document.documentElement.classList.add('dark');
  }
  document.getElementById('theme').onclick = () => {
    document.documentElement.classList.toggle('dark');
    localStorage.setItem('SARA_THEME', document.documentElement.classList.contains('dark') ? 'dark' : 'light');
  };

  // Key management (optional)
  const keyInput = document.getElementById('apiKey');
  const keyStatus = document.getElementById('keyStatus');
  keyInput.value = localStorage.getItem('SARA_API_KEY') || '';
  const bearerHeaders = () => {
    const headers = { 'Content-Type': 'application/json' };
    const k = (localStorage.getItem('SARA_API_KEY') || '').trim();
    if (k) headers['Authorization'] = 'Bearer ' + k;
    return headers;
  };
  document.getElementById('saveKey').onclick = () => {
    localStorage.setItem('SARA_API_KEY', keyInput.value || '');
    keyStatus.textContent = 'Key saved';
    setTimeout(()=> keyStatus.textContent = '', 1200);
  };
  document.getElementById('clearKey').onclick = () => {
    localStorage.removeItem('SARA_API_KEY');
    keyInput.value = '';
    keyStatus.textContent = 'Key cleared';
    setTimeout(()=> keyStatus.textContent = '', 1200);
  };

  // ---------- API ----------
  async function loadCard() {
    const out = document.getElementById('card');
    out.textContent = 'Loading‚Ä¶';
    try {
      const r = await fetch(`${API_BASE}/api/currentCard`, {
        headers: { 'Accept': 'application/json' }
      });
      const ct = (r.headers.get('content-type') || '').toLowerCase();
      if (!r.ok) {
        const body = await r.text();
        throw new Error(`HTTP ${r.status} on /api/currentCard ‚Äî ${body.slice(0,200)}`);
      }
      if (ct.includes('application/json')) {
        const j = await r.json();
        out.textContent = JSON.stringify(j, null, 2);
      } else {
        const t = await r.text();
        throw new Error(`Expected JSON, got ${ct || 'unknown content-type'} ‚Äî ${t.slice(0,200)}`);
      }
    } catch (e) {
      out.textContent = String(e);
    }
  }

  async function saveReflection() {
    const status = document.getElementById('status');
    const result = document.getElementById('result');
    const saveBtn = document.getElementById('save');
    const textEl = document.getElementById('reflectText');
    const text = textEl.value.trim();

    if (!text) {
      status.textContent = 'Please type something first.';
      status.className = 'err';
      return;
    }

    // disable while saving
    saveBtn.disabled = true;
    status.textContent = 'Saving‚Ä¶';
    status.className = 'muted';

    try {
      const r = await fetch(`${API_BASE}/api/reflect`, {
        method: 'POST',
        headers: bearerHeaders(),
        body: JSON.stringify({ text })
      });
      const ct = (r.headers.get('content-type') || '').toLowerCase();
      if (!r.ok) {
        const body = await r.text();
        throw new Error(`HTTP ${r.status} on /api/reflect ‚Äî ${body.slice(0,200)}`);
      }
      let j;
      if (ct.includes('application/json')) {
        j = await r.json();
      } else {
        const t = await r.text();
        throw new Error(`Expected JSON, got ${ct || 'unknown content-type'} ‚Äî ${t.slice(0,200)}`);
      }
      result.textContent = j.summary || "Saved.";

      if (j.ok) {
        status.textContent = 'Saved ‚úì';
        status.className = 'ok flash';
        textEl.value = '';
        loadCard();
      } else {
        status.textContent = j.error || 'Failed';
        status.className = 'err';
      }
    } catch (e) {
      status.textContent = String(e);
      status.className = 'err';
    } finally {
      // Re-enable & remove flash after it completes
      saveBtn.disabled = false;
      setTimeout(() => status.classList.remove('flash'), 1200);
    }
  }

  // ---------- Wiring & Shortcuts ----------
  document.getElementById('refresh').onclick = loadCard;
  document.getElementById('save').onclick = saveReflection;

  const input = document.getElementById('reflectText');
  input.addEventListener('keydown', (e) => {
    // Save: Cmd/Ctrl + Enter
    if ((e.metaKey || e.ctrlKey) && e.key === 'Enter') {
      e.preventDefault();
      saveReflection();
    }
    // Ask SARA: Shift + Enter
    if (e.shiftKey && e.key === 'Enter') {
      e.preventDefault();
      // call askSara if it exists (defined in later script)
      if (typeof askSara === 'function') askSara();
    }
    // Clear: Esc
    if (e.key === 'Escape') {
      input.value = '';
    }
  });

  // Global: Refresh card with Cmd/Ctrl + Shift + R (avoids browser Cmd+R)
  document.addEventListener('keydown', (e) => {
    if ((e.metaKey || e.ctrlKey) && e.shiftKey && (e.key.toLowerCase() === 'r')) {
      e.preventDefault();
      loadCard();
    }
  });

  // Focus the textbox on load (autofocus attribute is a hint; do it explicitly too)
  window.addEventListener('load', () => { input.focus(); input.selectionStart = input.selectionEnd = input.value.length; });

  // Initial load
  loadCard();
</script>
<script>
async function speakText(text) {
  const apiKey = (localStorage.getItem('SARA_API_KEY') || '').trim();
  const res = await fetch(`${API_BASE}/api/tts`, {
    method: "POST",
    headers: {
      "Content-Type": "application/json",
      ...(apiKey ? { "Authorization": `Bearer ${apiKey}` } : {})
    },
    body: JSON.stringify({ text, voice: "alloy" })
  });
  if (!res.ok) {
    const err = await res.text().catch(()=>res.statusText);
    throw new Error(`TTS failed: ${res.status} ${err}`);
  }
  const blob = await res.blob();
  const url = URL.createObjectURL(blob);
  const audio = document.getElementById("ttsAudio");
  audio.style.display = "block";
  audio.src = url;
  await audio.play();
}

async function chatAndGetReply(text) {
  const apiKey = (localStorage.getItem('SARA_API_KEY') || '').trim();
  const res = await fetch(`${API_BASE}/api/chat`, {
    method: "POST",
    headers: {
      "Content-Type": "application/json",
      ...(apiKey ? { "Authorization": `Bearer ${apiKey}` } : {})
    },
    body: JSON.stringify({ text })
  });
  if (!res.ok) {
    const err = await res.text().catch(()=>res.statusText);
    throw new Error(`Chat failed: ${res.status} ${err}`);
  }
  const j = await res.json();
  if (!j || !j.ok || !j.reply) {
    throw new Error("Chat failed: empty reply");
  }
  return j.reply;
}

// --- One-time init overlay: unlock audio, pre-warm mic, greet
let audioEl = document.getElementById("ttsAudio");
// If the element was removed, recreate a hidden one:
if (!audioEl) {
  audioEl = document.createElement("audio");
  audioEl.id = "ttsAudio";
  audioEl.style.display = "none";
  document.body.appendChild(audioEl);
}

// Keep a shared stream so subsequent recordings start immediately
let micReady = false;

async function initSara() {
  // 1) unlock audio with a very short silent buffer (satisfies autoplay policies)
  try {
    const ctx = new (window.AudioContext || window.webkitAudioContext)();
    const buf = ctx.createBuffer(1, 1, 22050);
    const src = ctx.createBufferSource();
    src.buffer = buf;
    src.connect(ctx.destination);
    src.start(0);
  } catch {}

  // 2) ask for mic once and keep the stream around
  try {
    if (!currentStream) {
      currentStream = await navigator.mediaDevices.getUserMedia({ audio: true });
    }
    micReady = true;
  } catch (e) {
    console.warn("Mic permission not granted yet:", e);
    // We still continue; user can use typing.
  }

  // 3) greet Saif
  try {
    await speakText("Hey Saif, how can I assist you today?");
  } catch (e) {
    console.warn("Greeting TTS failed:", e);
  }
}

const initOverlay = document.getElementById("initOverlay");
const startBtn = document.getElementById("startSaraBtn");
if (startBtn) {
  startBtn.addEventListener("click", async () => {
    startBtn.disabled = true;
    try {
      await initSara();
    } finally {
      if (initOverlay) initOverlay.style.display = "none";
      startBtn.disabled = false;
    }
  });
};

// --- Hold-to-talk (press and hold to record; on release: STT -> Chat -> TTS)
let mediaRecorder, chunks = [], currentStream;
const micBtn = document.getElementById("micBtn");
const resultBox = document.getElementById("result");
let isRecording = false;

function updateMicUI() {
  if (!micBtn) return;
  if (isRecording) {
    micBtn.classList.add("recording");
    micBtn.title = "Tap to stop";
    micBtn.textContent = "‚è∫Ô∏è";
  } else {
    micBtn.classList.remove("recording");
    micBtn.title = "Tap to talk";
    micBtn.textContent = "üéôÔ∏è";
  }
}
async function toggleRecording() {
  if (isRecording) {
    try { stopRecording(); } finally { isRecording = false; updateMicUI(); }
    return;
  }
  await startRecording();
  isRecording = true;
  updateMicUI();
}

// Ask SARA with the textarea content, show and speak reply
async function askSara() {
  try {
    const textEl = document.getElementById("reflectText");
    const text = (textEl.value || "").trim();
    if (!text) { alert("Type something to ask SARA."); return; }
    const reply = await chatAndGetReply(text);
    if (resultBox) resultBox.textContent = reply;
    await speakText(reply);
  } catch (e) {
    console.error(e);
    alert(e.message || "Chat failed");
  }
}

const askBtn = document.getElementById("askBtn");
if (askBtn) {
  askBtn.addEventListener("click", askSara);
}

// Choose a MIME type the browser supports; Safari often lacks webm support
function pickMime() {
  if (window.MediaRecorder && MediaRecorder.isTypeSupported('audio/webm')) {
    return { mime: 'audio/webm', ext: 'webm' };
  }
  if (window.MediaRecorder && MediaRecorder.isTypeSupported('audio/mp4')) {
    return { mime: 'audio/mp4', ext: 'm4a' };
  }
  return { mime: '', ext: 'wav' };
}

async function startRecording() {
  try {
    if (!currentStream) {
      currentStream = await navigator.mediaDevices.getUserMedia({ audio: true });
    }
    const { mime } = pickMime();

    chunks = [];
    mediaRecorder = mime ? new MediaRecorder(currentStream, { mimeType: mime })
                         : new MediaRecorder(currentStream);

    mediaRecorder.ondataavailable = (e) => {
      if (e.data && e.data.size) chunks.push(e.data);
    };

    mediaRecorder.onstop = async () => {
      try {
        // flush any buffered data and allow one tick for final chunk
        try { mediaRecorder.requestData?.(); } catch {}
        await new Promise(r => setTimeout(r, 50));

        const totalBytes = chunks.reduce((n, b) => n + (b?.size || 0), 0);
        if (!totalBytes) {
          alert("No audio captured. Try holding for ~1s, or use Chrome if you‚Äôre on Safari.");
          return;
        }

        const { ext } = pickMime();
        const blob = new Blob(chunks, { type: chunks[0]?.type || 'audio/webm' });
        const form = new FormData();
        form.append("audio", blob, `mic.${ext}`);

        const apiKey = (localStorage.getItem("SARA_API_KEY") || "").trim();
        const sttRes = await fetch(`${API_BASE}/api/stt`, {
          method: "POST",
          headers: { ...(apiKey ? { "Authorization": `Bearer ${apiKey}` } : {}) },
          body: form
        });

        if (!sttRes.ok) {
          const t = await sttRes.text().catch(() => sttRes.statusText);
          throw new Error(`STT failed: ${sttRes.status} ${t}`);
        }

        const stt = await sttRes.json().catch(() => ({}));
        if (!stt || !stt.ok || !stt.text) throw new Error("STT failed");

        const textEl = document.getElementById("reflectText");
        if (textEl) textEl.value = stt.text;

        const reply = await chatAndGetReply(stt.text);
        if (resultBox) resultBox.textContent = reply;
        await speakText(reply);
      } catch (e) {
        console.error(e);
        alert(e.message || "Mic/Chat failed");
      } finally {
        isRecording = false;
        updateMicUI();
        currentStream?.getTracks()?.forEach(t => t.stop());
        currentStream = null;
      }
    };

    mediaRecorder.start();
  } catch (e) {
    console.error(e);
    alert("Mic access failed (check browser permissions).");
    isRecording = false;
    updateMicUI();
  }
}

function stopRecording() {
  try {
    if (mediaRecorder && mediaRecorder.state !== "inactive") mediaRecorder.stop();
  } catch {}
}

if (micBtn) {
  micBtn.addEventListener("click", (e) => {
    e.preventDefault();
    toggleRecording();
  });
}
// Space bar toggles recording (global) unless focused on an input/textarea
document.addEventListener("keydown", (e) => {
  const tag = (document.activeElement?.tagName || "").toLowerCase();
  const typing = tag === "input" || tag === "textarea";
  if (!typing && e.code === "Space" && !e.repeat) {
    e.preventDefault();
    toggleRecording();
  }
});
</script>